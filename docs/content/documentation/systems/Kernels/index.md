# Kernels System

A "Kernel" is a piece of physics. It can represent one or more operators or
terms in the weak form of a partial differential equation.  With all terms on
the left-hand-side, their sum is referred to as the "residual". The residual
is evaluated at several integration quadrature points over the problem
domain. To implement your own physics in MOOSE, you create your own
kernel by subclassing the MOOSE `Kernel` class.  

In a `Kernel` subclass the `computeQpResidual()` function **must** be overridden.  This is where you
implement your PDE weak form terms.  The following member functions can
optionally be overridden:

* `computeQpJacobian()`
* `computeQpOffDiagJacobian()`

These two functions provide extra information that can help the numerical
solver(s) converge faster and better.  Inside your Kernel class, you have
access to several member variables for computing the residual and Jacobian
values in the above mentioned functions:

* `_i`, `_j`: indices for the current test and trial shape functions respectively.
* `_qp`: current quadrature point index.
* `_u`, `_grad_u`: value and gradient of the variable this Kernel operates on;
  indexed by `_qp` (i.e. `_u[_qp]`).
* `_test`, `_grad_test`: value ($\psi$) and gradient ($\nabla \psi$) of the
  test functions at the q-points; indexed by `_i` and then `_qp` (i.e., ``_test[_i][_qp]``).
* `_phi`, `_grad_phi`: value ($\phi$) and gradient ($\nabla \phi$) of the
    trial functions at the q-points; indexed by `_j` and then `_qp` (i.e., ``_phi[_j][_qp]``).
* `_q_point`: XYZ coordinates of the current quadrature point.
* `_current_elem`: pointer to the current element being operated on.

## Custom Kernel Creation

To create a custom kernel, you can follow the pattern of the [`Diffusion`](framework/Diffusion.md)
kernel implemented and included in the MOOSE framework.  Additionally, [Example 2](examples/custom_kernel.md) provides a step-by-step overview of creating your own custom kernel.

The strong-form of the diffusion equations is defined on a 3-D domain $\Omega$ as: find $u$ such
that

\begin{equation}
\label{strong-form}
\begin{aligned}
-\nabla\cdot\nabla u - f &= 0 \in \Omega\\
u|_{\partial\Omega_1} &= g_1\\
\nabla u\cdot \hat{n} |_{\partial\Omega_2} &= g_2,
\end{aligned}
\end{equation}

where $\partial\Omega_1$ is defined as the boundary on which the value of $u$ is fixed to a known constant $g_1$, $\partial\Omega_2$ is defined as the boundary on which the flux across the boundary is fixed to a known constant $g_2$, and $\hat{n} is the boundary outward normal.

The weak form is generated by multiplying by a test function ($\psi_i$) and integrating
over the domain (using inner-product notation):

$$
(-\nabla\cdot\nabla u_h, \psi_i) - (f, \psi_i) = 0\quad \forall\,\psi_i
$$
and then integrating by parts which gives the weak form:

\begin{equation}
\label{weak-form}
(\nabla u_h, \nabla \psi_i) - (f, \psi_i) - \langle g_2, \psi_i\rangle = 0\quad \forall\,\psi_i,
\end{equation}
where $u_h$ is known as the trial function that defines the finite element discretization, $u
\approx u_h = \sum_{j=1}^N u_j \phi_j$, with $\phi_j$ being the basis functions.

The Jacobian, which is the derivative of \eqref{weak-form} with respect to $u_j$ $\left(\frac{\partial (.)}{\partial u_j}\right)$, is defined as:

$$ (\nabla \phi_j, \nabla \psi_i)\quad \forall\,\psi_i$$

The diffusion kernel header and implementation files are:

!text framework/include/kernels/Diffusion.h max-height=400px overflow-y=scroll

!text framework/src/kernels/Diffusion.C max-height=400px overflow-y=scroll

Before a custom physics kernel is available for use, it must be registered in your application.
This is done in e.g. `src/base/YourApp.C` for the YourApp application.

```cpp
// src/base/YourApp.C contents

#include "YourKernel.h"

...

int YourApp::registerObjects(Factory & factory)
{
  ...
  registerKernel(YourKernel);
  ...
}

...
```


## Time Derivative Kernels

You can create a time-derivative term/kernel by subclassing `TimeKernel`
instead of `Kernel`.  For example, the residual contribution for a time
derivative term is:

$$\left(\frac{\partial u_h}{\partial t}, \psi_i\right)$$

where $u_h$ is the finite element solution, and

\begin{equation}
\label{time-derivative}
\frac{\partial u_h}{\partial t}
\equiv
\frac{\partial}{\partial t}
\left(
    \sum_k u_k \phi_k
\right)
= \sum_k \frac{\partial u_k}{\partial t} \phi_k
\end{equation}

because you can interchange the order of differentiation and summation.

In the equation above, $\frac{\partial u_k}{\partial t}$ is the time
derivative of the $k$th finite element coefficient of $u_h$. While the
exact form of this derivative depends on the time stepping scheme, without
much loss of generality, we can assume the following form for the time
derivative:

$$ \frac{\partial u_k}{\partial t} = a u_k + b $$

for some constants $a$, $b$ which depend on $\Delta t$ and the timestepping method.

The derivative of equation \eqref{time-derivative} with respect to $u_j$ is then:

\begin{equation}
\frac{\partial}{\partial u_j} \left(
    \sum_k \frac{\partial u_k}{\partial t} \phi_k
\right) =
\frac{\partial }{\partial u_j} \left(
    \sum_k (a u_k + b) \phi_k
\right)
 = a \phi_j
\end{equation}

So that the Jacobian term for equation \eqref{time-derivative} is

$$\left(a \phi_j, \psi_i\right)$$

where $a$ is what we call `du_dot_du` in MOOSE.

Therefore the `computeQpResidual()` function for our time-derivative term
kernel looks like:

text
```cpp
return _test[_i][_qp] * _u_dot[_qp];
```

And the corresponding `computeQpJacobian()` is:

```cpp
return _test[_i][_qp] * _phi[_j][_qp] * _du_dot_du[_qp];
```

## Further Kernel Documentation

Several specialized kernel types exist in MOOSE each with useful
functionality.  Details for each are in the sections below.

!subobjects /Kernels
